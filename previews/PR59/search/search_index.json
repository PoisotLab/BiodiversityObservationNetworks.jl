{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#biodiversityobservationnetworksjl","title":"BiodiversityObservationNetworks.jl","text":"<p>The purpose of this package is to provide a high-level, extensible, modular interface to the selection of sampling point for biodiversity processes in space. It is based around a collection of types representing point selection algorithms, used to select the most informative sampling points based on raster data. Specifically, the algorithms work from a layer indicating entropy at each location.</p> <p>This package is in development</p> <p>The <code>BiodiversityObservationNetworks.jl</code> package is currently under development. The API is not expected to change a lot, but it may change in order to facilitate the integration of new features.</p> <p></p> <p></p>"},{"location":"#high-level-types","title":"High-level types","text":"<p># <code>BiodiversityObservationNetworks.BONSampler</code> \u2014 Type.</p> <pre><code>BONSampler\n</code></pre> <p>A union of the abstract types <code>BONSeeder</code> and <code>BONRefiner</code>. Both types return a tuple with the coordinates as a vector of <code>CartesianIndex</code>, and the weight matrix as a <code>Matrix</code> of <code>AbstractFloat</code>, in that order.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.BONSeeder</code> \u2014 Type.</p> <pre><code>abstract type BONSeeder end\n</code></pre> <p>A <code>BONSeeder</code> is an algorithm for proposing sampling locations using a raster of weights, represented as a matrix, in each cell.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.BONRefiner</code> \u2014 Type.</p> <pre><code>abstract type BONRefiner end\n</code></pre> <p>A <code>BONRefiner</code> is an algorithm for proposing sampling locations by refining a set of candidate points to a smaller set of 'best' points.</p> <p>source</p> <p></p> <p></p>"},{"location":"#seeder-and-refiner-functions","title":"Seeder and refiner functions","text":"<p># <code>BiodiversityObservationNetworks.seed</code> \u2014 Function.</p> <pre><code>seed(sampler::ST, uncertainty::Matrix{T})\n</code></pre> <p>Produces a set of candidate sampling locations in a vector <code>coords</code> of length numpoints from a raster <code>uncertainty</code> using <code>sampler</code>, where <code>sampler</code> is a <code>BONSeeder</code>.   </p> <p>source</p> <pre><code>seed!(coords::Vector{CartesianIndex}, sampler::ST)\n</code></pre> <p>The curried version of <code>seed!</code>, which returns a function that acts on the input uncertainty layer passed to the curried function (<code>u</code> below).</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.seed!</code> \u2014 Function.</p> <pre><code>seed!(coords::Vector{CartesianIndex}, sampler::ST, uncertainty::Matrix{T})\n</code></pre> <p>Puts a set of candidate sampling locations in the preallocated vector <code>coords</code> from a raster <code>uncertainty</code> using <code>sampler</code>, where <code>sampler</code> is a <code>BONSeeder</code>.</p> <ul> <li>Seeder's work on rasters, refiners work on set of coordinates.</li> </ul> <p>source</p> <pre><code>seed!(coords::Vector{CartesianIndex}, sampler::ST)\n</code></pre> <p>The curried version of <code>seed!</code>, which returns a function that acts on the input uncertainty layer passed to the curried function (<code>u</code> below).</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.refine</code> \u2014 Function.</p> <pre><code>refine(pool::Vector{CartesianIndex}, sampler::ST, uncertainty::Matrix{T})\n</code></pre> <p>Refines a set of candidate sampling locations and returns a vector <code>coords</code> of length numpoints from a vector  of coordinates <code>pool</code> using <code>sampler</code>, where <code>sampler</code> is a <code>BONRefiner</code>.</p> <p>source</p> <pre><code>refine(sampler::BONRefiner)\n</code></pre> <p>Returns a curried function of <code>refine</code> with two methods: both are using the output of <code>seed</code>, one in its packed form, the other in its splatted form.</p> <p>source</p> <pre><code>refine(pack, sampler::BONRefiner)\n</code></pre> <p>Calls <code>refine</code> on the appropriatedly splatted version of <code>pack</code>.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.refine!</code> \u2014 Function.</p> <pre><code>refine!(cooords::Vector{CartesianIndex}, pool::Vector{CartesianIndex}, sampler::ST, uncertainty::Matrix{T})\n</code></pre> <p>Refines a set of candidate sampling locations in the preallocated vector <code>coords</code> from a vector  of coordinates <code>pool</code> using <code>sampler</code>, where <code>sampler</code> is a <code>BONRefiner</code>.</p> <p>source</p> <pre><code>refine!(cooords::Vector{CartesianIndex}, pool::Vector{CartesianIndex}, sampler::ST, uncertainty::Matrix{T})\n</code></pre> <p>The curried version of <code>refine!</code>, which returns a function that acts on the input coordinate pool passed to the curried function (<code>p</code> below).</p> <p>source</p> <p></p> <p></p>"},{"location":"#seeder-algorithms","title":"Seeder algorithms","text":"<p># <code>BiodiversityObservationNetworks.BalancedAcceptance</code> \u2014 Type.</p> <pre><code>BalancedAcceptance\n</code></pre> <p>A <code>BONSeeder</code> that uses Balanced-Acceptance Sampling (Van-dem-Bates et al. 2017 https://doi.org/10.1111/2041-210X.13003)</p> <p>source</p> <p></p> <p></p>"},{"location":"#refiner-algorithms","title":"Refiner algorithms","text":"<p># <code>BiodiversityObservationNetworks.AdaptiveSpatial</code> \u2014 Type.</p> <pre><code>AdaptiveSpatial\n</code></pre> <p>...</p> <p>numpoints, an Integer (def. 50), specifying the number of points to use.</p> <p>\u03b1, an AbstractFloat (def. 1.0), specifying ...</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.Uniqueness</code> \u2014 Type.</p> <pre><code>Uniqueness\n</code></pre> <p>A <code>BONRefiner</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"#helper-functions","title":"Helper functions","text":"<p># <code>BiodiversityObservationNetworks.squish</code> \u2014 Function.</p> <pre><code>squish(layers, W, \u03b1)\n</code></pre> <p>Takes a set of <code>n</code> layers and squishes them down to a single layer.</p> <pre><code>    numcolumns = size(W,2)\n    for i in 1:numcolumns\n        W[:,i] ./= sum(W[:,i])\n    end\n</code></pre> <p>For a coordinate in the raster (i,j), denote the vector of values across all locations at that coordinate v\u20d7\u1d62\u2c7c. The value at that coordinate in squished layer, s\u20d7\u1d62\u2c7c, is computed in two steps.</p> <p>(1): First we apply a weights matrix, <code>W``, with</code>n<code>rows and</code>m<code>columns (</code>m<code>&lt;</code>n<code>), to reduce the initial</code>n<code>layers down to a set of</code>m` layers, each of which corresponds  to a particular target of optimization. For example, we may want to propose sampling  locations that are optimized to best sample  abalance multiple criteria, like (a) the  current distribution of a species and (b) if that distribution is changing over time.</p> <p>Each entry in the weights matrix <code>W</code> corresponds to the 'importance' of the layer in the corresponding row to the successful measurement of the target of the corresponding column. As such, each column of <code>W</code> must sum to 1.0. using Optim</p> <p>For each location, the value of the condensed layer <code>t\u1d62</code>, corresponding to target <code>i</code>, at  coordinate (i,j) is given by the dot product of v\u20d7\u1d62\u2c7c and the <code>i</code>-th column of <code>W</code>.</p> <p>(2): Apply a weighted average across each target layer. To produce the final output layer, we apply a weighted average to each target layer, where the weights are provided in the vector \u03b1\u20d7 of length <code>m</code>.</p> <p>The final value of the squished layer at (i,j) is given by s\u20d7\u1d62\u2c7c = \u2211\u2093 \u03b1\u2093*t\u1d62\u2c7c(x), where t\u1d62\u2c7c(x) is the value of the x-th target layer at (i,j).</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.entropize!</code> \u2014 Function.</p> <pre><code>entropize!(U::Matrix{AbstractFloat}, A::Matrix{Number})\n</code></pre> <p>This function turns a matrix <code>A</code> (storing measurement values) into pixel-wise entropy values, stored in a matrix <code>U</code> (that is previously allocated).</p> <p>Pixel-wise entropy is determined by measuring the empirical probability of randomly picking a value in the matrix that is either lower or higher than the pixel value. The entropy of both these probabilities are calculated using the -p\u00d7log(2,p) formula. The entropy of the pixel is the sum of the two entropies, so that it is close to 1 for values close to the median, and close to 0 for values close to the extreme of the distribution.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.entropize</code> \u2014 Function.</p> <pre><code>entropize(A::Matrix{Number})\n</code></pre> <p>Allocation version of <code>entropize!</code>.</p> <p>source</p>"}]}