{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#biodiversityobservationnetworksjl","title":"BiodiversityObservationNetworks.jl","text":"<p>The purpose of this package is to provide a high-level, extensible, modular interface to the selection of sampling point for biodiversity processes in space. It is based around a collection of types representing point selection algorithms, used to select the most informative sampling points based on raster data. Specifically, many algorithms work from a layer indicating entropy of a model based prediction at each location.</p> <p>This package is in development</p> <p>The <code>BiodiversityObservationNetworks.jl</code> package is currently under development. The API is not expected to change a lot, but it may change in order to facilitate the integration of new features.</p> <p></p> <p></p>"},{"location":"#high-level-types","title":"High-level types","text":"<p># <code>BiodiversityObservationNetworks.BONSampler</code> \u2014 Type.</p> <pre><code>BONSampler\n</code></pre> <p>A union of the abstract types <code>BONSeeder</code> and <code>BONRefiner</code>. Both types return a tuple with the coordinates as a vector of <code>CartesianIndex</code>, and the weight matrix as a <code>Matrix</code> of <code>AbstractFloat</code>, in that order.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.BONSeeder</code> \u2014 Type.</p> <pre><code>abstract type BONSeeder end\n</code></pre> <p>A <code>BONSeeder</code> is an algorithm for proposing sampling locations using a raster of weights, represented as a matrix, in each cell.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.BONRefiner</code> \u2014 Type.</p> <pre><code>abstract type BONRefiner end\n</code></pre> <p>A <code>BONRefiner</code> is an algorithm for proposing sampling locations by refining a set of candidate points to a smaller set of 'best' points.</p> <p>source</p> <p></p> <p></p>"},{"location":"#seeder-and-refiner-functions","title":"Seeder and refiner functions","text":"<p># <code>BiodiversityObservationNetworks.seed</code> \u2014 Function.</p> <pre><code>seed(sampler::ST)\n</code></pre> <p>Produces a set of candidate sampling locations in a vector <code>coords</code> of length numsites from a raster using <code>sampler</code>, where <code>sampler</code> is a <code>BONSeeder</code>.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.seed!</code> \u2014 Function.</p> <pre><code>seed!(coords::Vector{CartesianIndex}, sampler::ST, uncertainty::Matrix{T})\n</code></pre> <p>Puts a set of candidate sampling locations in the preallocated vector <code>coords</code> from a raster <code>uncertainty</code> using <code>sampler</code>, where <code>sampler</code> is a <code>BONSeeder</code>.</p> <ul> <li>Seeder's work on rasters, refiners work on set of coordinates.</li> </ul> <p>source</p> <p># <code>BiodiversityObservationNetworks.refine</code> \u2014 Function.</p> <pre><code>refine(pool::Vector{CartesianIndex}, sampler::ST)\n</code></pre> <p>Refines a set of candidate sampling locations and returns a vector <code>coords</code> of length numsites from a vector  of coordinates <code>pool</code> using <code>sampler</code>, where <code>sampler</code> is a <code>BONRefiner</code>.</p> <p>source</p> <pre><code>refine(sampler::BONRefiner)\n</code></pre> <p>Returns a curried function of <code>refine</code></p> <p>source</p> <p># <code>BiodiversityObservationNetworks.refine!</code> \u2014 Function.</p> <pre><code>refine!(cooords::Vector{CartesianIndex}, pool::Vector{CartesianIndex}, sampler::ST)\n</code></pre> <p>Refines a set of candidate sampling locations in the preallocated vector <code>coords</code> from a vector of coordinates <code>pool</code> using <code>sampler</code>, where <code>sampler</code> is a <code>BONRefiner</code>.</p> <p>source</p> <pre><code>refine!(cooords::Vector{CartesianIndex}, pool::Vector{CartesianIndex}, sampler::ST)\n</code></pre> <p>The curried version of <code>refine!</code>, which returns a function that acts on the input coordinate pool passed to the curried function (<code>p</code> below).</p> <p>source</p> <p></p> <p></p>"},{"location":"#seeder-algorithms","title":"Seeder algorithms","text":"<p># <code>BiodiversityObservationNetworks.BalancedAcceptance</code> \u2014 Type.</p> <pre><code>BalancedAcceptance\n</code></pre> <p>A <code>BONSeeder</code> that uses Balanced-Acceptance Sampling (Van-dem-Bates et al. 2017 https://doi.org/10.1111/2041-210X.13003)</p> <p>source</p> <p></p> <p></p>"},{"location":"#refiner-algorithms","title":"Refiner algorithms","text":"<p># <code>BiodiversityObservationNetworks.AdaptiveSpatial</code> \u2014 Type.</p> <pre><code>AdaptiveSpatial\n</code></pre> <p>...</p> <p>numsites, an Integer (def. 50), specifying the number of points to use.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.Uniqueness</code> \u2014 Type.</p> <pre><code>Uniqueness\n</code></pre> <p>A <code>BONRefiner</code></p> <p>source</p> <p></p> <p></p>"},{"location":"#helper-functions","title":"Helper functions","text":"<p>Missing docstring.</p> <p>Missing docstring for <code>squish</code>. Check Documenter's build log for details.</p> <p># <code>BiodiversityObservationNetworks.entropize!</code> \u2014 Function.</p> <pre><code>entropize!(U::Matrix{AbstractFloat}, A::Matrix{Number})\n</code></pre> <p>This function turns a matrix <code>A</code> (storing measurement values) into pixel-wise entropy values, stored in a matrix <code>U</code> (that is previously allocated).</p> <p>Pixel-wise entropy is determined by measuring the empirical probability of randomly picking a value in the matrix that is either lower or higher than the pixel value. The entropy of both these probabilities are calculated using the -p\u00d7log(2,p) formula. The entropy of the pixel is the sum of the two entropies, so that it is close to 1 for values close to the median, and close to 0 for values close to the extreme of the distribution.</p> <p>source</p> <p># <code>BiodiversityObservationNetworks.entropize</code> \u2014 Function.</p> <pre><code>entropize(A::Matrix{Number})\n</code></pre> <p>Allocation version of <code>entropize!</code>.</p> <p>source</p>"},{"location":"bibliography/","title":"Bibliography","text":""},{"location":"bibliography/#references","title":"References","text":""},{"location":"vignettes/entropize/","title":"Entropize","text":""},{"location":"vignettes/entropize/#getting-the-entropy-matrix","title":"Getting the entropy matrix","text":"<p>For some applications, we want to place points to capture the maximum amount of information, which is to say that we want to sample a balance of entropy values, as opposed to absolute values. In this vignette, we will walk through an example using the <code>entropize</code> function to convert raw data to entropy values. </p> <pre><code>using BiodiversityObservationNetworks\nusing NeutralLandscapes\nusing CairoMakie\n</code></pre> <p>Entropy is problem-specific</p> <p>The solution presented in this vignette is a least-assumption solution based on the empirical values given in a matrix of measurements. In a lot of situations, this is not the entropy that you want. For example, if your pixels are storing probabilities of Bernoulli events, you can directly use the entropy of the events in the entropy matrix.</p> <p>We start by generating a random matrix of measurements:</p> <pre><code>measurements = rand(MidpointDisplacement(), (200, 200)) .* 100\nheatmap(measurements)\n</code></pre> <p></p> <p>Using the <code>entropize</code> function will convert these values into entropy at the pixel scale: </p> <p><code>@example 1 U = entropize(measurements) locations =     seed(BalancedAcceptance(; numsites = 100, uncertainty=U))</code></p>"},{"location":"vignettes/overview/","title":"Overview","text":""},{"location":"vignettes/overview/#an-introduction-to-biodiversityobservationnetworks","title":"An introduction to BiodiversityObservationNetworks","text":"<p>In this vignette, we will walk through the basic functionalities of the package, by generating a random uncertainty matrix, and then using a seeder and a refiner to decide which locations should be sampled in order to gain more insights about the process generating this entropy. </p> <pre><code>using BiodiversityObservationNetworks\nusing NeutralLandscapes\nusing CairoMakie\n</code></pre> <p>In order to simplify the process, we will use the NeutralLandscapes package to generate a 100\u00d7100 pixels landscape, where each cell represents the entropy (or information content) in a unit we can sample:</p> <pre><code>U = rand(MidpointDisplacement(0.5), (100, 100))\nheatmap(U)\n</code></pre> <p></p> <p>In practice, this uncertainty matrix is likely to be derived from an application of the hyper-parameters optimization step, which is detailed in other vignettes.</p> <p>The first step of defining a series of locations to sample is to use a <code>BONSeeder</code>, which will generate a number of relatively coarse proposals that cover the entire landscape, and have a balanced distribution in space. We do so using the <code>BalancedAcceptance</code> sampler, which can be tweaked to capture more (or less) uncertainty. To start with, we will extract 200 candidate points, i.e. 200 possible locations which will then be refined. </p> <pre><code>candidates = seed(BalancedAcceptance(; numsites = 200));\n</code></pre> <pre><code>200-element Vector{CartesianIndex}:\n CartesianIndex(7, 31)\n CartesianIndex(32, 48)\n CartesianIndex(20, 6)\n CartesianIndex(45, 22)\n CartesianIndex(4, 39)\n CartesianIndex(29, 11)\n CartesianIndex(17, 28)\n CartesianIndex(42, 44)\n CartesianIndex(10, 17)\n CartesianIndex(35, 33)\n \u22ee\n CartesianIndex(38, 4)\n CartesianIndex(7, 21)\n CartesianIndex(32, 38)\n CartesianIndex(19, 10)\n CartesianIndex(44, 27)\n CartesianIndex(4, 43)\n CartesianIndex(29, 15)\n CartesianIndex(16, 32)\n CartesianIndex(41, 49)\n</code></pre> <p>We can have a look at the first five points: </p> <pre><code>candidates[1:5]\n</code></pre> <pre><code>5-element Vector{CartesianIndex}:\n CartesianIndex(7, 31)\n CartesianIndex(32, 48)\n CartesianIndex(20, 6)\n CartesianIndex(45, 22)\n CartesianIndex(4, 39)\n</code></pre> <p>The positions of locations to sample are given as a vector of <code>CartesianIndex</code>, which are coordinates in the uncertainty matrix. Once we have generated a candidate proposal, we can further refine it using a <code>BONRefiner</code> \u2013 in this case, <code>AdaptiveSpatial</code>, which performs adaptive spatial sampling (maximizing the distribution of entropy while minimizing spatial auto-correlation).</p> <p>```@example 1 locations = refine(candidates, AdaptiveSpatial(; numsites = 50, uncertainty=U)) locations[1:5] <pre><code>The reason we start from a candidate set of points is that some algorithms struggle with full landscapes, and work much better with a sub-sample of them. There is no hard rule (or no heuristic) to get a sense for how many points should be generated at the seeding step, and so experimentation is a must!\n\n\nThe previous code examples used a version of the `seed` and `refine` functions that is very useful if you want to change arguments between steps, or examine the content of the candidate pool of points. In addition to this syntax, both functions have a curried version that allows chaining them together using pipes (`|&gt;`):\n\n\n```@example 1\nlocations =\n    seed(BalancedAcceptance(; numsites = 200)) |&gt;\n    refine(AdaptiveSpatial(; numsites = 50, uncertainty=U))\n</code></pre></p> <p>This works because <code>seed</code> and <code>refine</code> have curried versions that can be used directly in a pipeline. Proposed sampling locations can then be overlayed onto the original uncertainty matrix: </p> <p><code>@example 1 plt = heatmap(U) scatter!(plt, [x[1] for x in locations], [x[2] for x in locations]) current_figure()</code></p>"},{"location":"vignettes/uniqueness/","title":"Uniqueness.jl","text":""},{"location":"vignettes/uniqueness/#selecting-environmentally-unique-locations","title":"Selecting environmentally unique locations","text":"<p>For some applications, we want to sample a set of locations that cover a broad range of values in environment space. Another way to rephrase this problem is to say we want to find the set of points with the least covariance in their environmental values.  </p> <p>To do this, we use a <code>BONRefiner</code> called <code>Uniqueness</code>. We'll start by loading the required packages. </p> <pre><code>using BiodiversityObservationNetworks\nusing SpeciesDistributionToolkit\nusing StatsBase\nusing NeutralLandscapes\nusing CairoMakie\n</code></pre> <pre><code>[ Info: Loading NeutralLandscapes support for SimpleSDMLayers.jl...\n</code></pre> <p>Consider setting your SDMLAYERS_PATH</p> <p>When accessing data using <code>SimpleSDMDatasets.jl</code>, it is best to set the <code>SDM_LAYERSPATH</code> environmental variable to tell <code>SimpleSDMDatasets.jl</code> where to download data. This can be done by setting <code>ENV[\"SDMLAYERS_PATH\"] = \"/home/user/Data/\"</code> or similar in the <code>~/.julia/etc/julia/startup.jl</code> file. (Note this will be different depending on where <code>julia</code> is installed.)</p> <pre><code>bbox = (left=-83.0, bottom=46.4, right=-55.2, top=63.7);\ntemp, precip, elevation =\n    convert(Float32, SimpleSDMPredictor(RasterData(WorldClim2, AverageTemperature); bbox...)),\n    convert(Float32, SimpleSDMPredictor(RasterData(WorldClim2, Precipitation); bbox...)),\n    convert(Float32, SimpleSDMPredictor(RasterData(WorldClim2, Elevation); bbox...));\n</code></pre> <pre><code>(SDM response \u2192 105\u00d7167 grid with 11478 Float32-valued cells, SDM response \u2192 105\u00d7167 grid with 11478 Float32-valued cells, SDM response \u2192 105\u00d7167 grid with 11478 Float32-valued cells)\n</code></pre> <p>Now we'll use the <code>stack</code> function to combine our four environmental layers into a single, 3-dimensional array, which we'll pass to our <code>Uniqueness</code> refiner.</p> <p>```@example 1 layers = BiodiversityObservationNetworks.stack([temp,precip,elevation]); <pre><code>```julia\nuncert = rand(MidpointDisplacement(0.8), size(temp), mask=temp);\nheatmap(uncert)\n</code></pre></p> <p></p> <p>Now we'll get a set of candidate points from a BalancedAcceptance seeder that has no bias toward higher uncertainty values.</p> <pre><code>candpts = seed(BalancedAcceptance(numsites=100));\n</code></pre> <pre><code>100-element Vector{CartesianIndex}:\n CartesianIndex(6, 45)\n CartesianIndex(31, 17)\n CartesianIndex(19, 34)\n CartesianIndex(44, 50)\n CartesianIndex(13, 1)\n CartesianIndex(38, 17)\n CartesianIndex(25, 34)\n CartesianIndex(50, 6)\n CartesianIndex(1, 23)\n CartesianIndex(26, 40)\n \u22ee\n CartesianIndex(40, 12)\n CartesianIndex(8, 29)\n CartesianIndex(33, 45)\n CartesianIndex(21, 3)\n CartesianIndex(46, 19)\n CartesianIndex(5, 36)\n CartesianIndex(30, 8)\n CartesianIndex(18, 25)\n CartesianIndex(43, 42)\n</code></pre> <p>Now we'll <code>refine</code> our <code>100</code> candidate points down to the 30 most environmentally unique.</p> <p><code>@example 1 finalpts = refine(candpts, Uniqueness(;numsites=30, layers=layers)) heatmap(uncert) scatter!([p[1] for p in candpts], [p[2] for p in candpts], color=:white) scatter!([p[1] for p in finalpts], [p[2] for p in finalpts], color=:dodgerblue, msc=:white) current_figure()</code></p>"}]}